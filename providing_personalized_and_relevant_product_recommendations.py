# -*- coding: utf-8 -*-
"""providing personalized and relevant product recommendations.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-Mk83mzYhocs-N7Gs66DuRCsqpQDr5fW
"""

from google.colab import files
uploaded = files.upload()

from google.colab import files
uploaded = files.upload()

import pandas as pd

# Load CSVs into dataframes
customer_df = pd.read_csv("customer_data_collection.csv")
product_df = pd.read_csv("product_recommendation_data.csv")

# Show the first few rows
print("ðŸ‘¤ Customer Data:")
print(customer_df.head())

print("\nðŸ“¦ Product Data:")
print(product_df.head())

# Drop unnamed columns
customer_df = customer_df.dropna(axis=1, how='all')
product_df = product_df.dropna(axis=1, how='all')

# Convert string lists to Python lists
import ast

customer_df['Browsing_History'] = customer_df['Browsing_History'].apply(ast.literal_eval)
customer_df['Purchase_History'] = customer_df['Purchase_History'].apply(ast.literal_eval)
product_df['Similar_Product_List'] = product_df['Similar_Product_List'].apply(ast.literal_eval)

from collections import Counter

# Group by customer segment and count purchase history
segment_purchases = {}

for segment in customer_df['Customer_Segment'].unique():
    purchases = customer_df[customer_df['Customer_Segment'] == segment]['Purchase_History']
    flat_list = [item for sublist in purchases for item in sublist]
    freq = Counter(flat_list)
    segment_purchases[segment] = freq.most_common(5)  # Top 5

# Example output
for segment, top_items in segment_purchases.items():
    print(f"\nTop products for {segment}:")
    for product, count in top_items:
        print(f"  {product} ({count} times)")

def recommend_products(customer_id):
    segment = customer_df[customer_df['Customer_ID'] == customer_id]['Customer_Segment'].values[0]
    recommendations = [item for item, _ in segment_purchases[segment]]
    return recommendations

recommend_products('C1003')  # Example

import sqlite3

# Create DB
conn = sqlite3.connect("recommendation_memory.db")
cursor = conn.cursor()

# Create table
cursor.execute('''
    CREATE TABLE IF NOT EXISTS recommendation_logs (
        customer_id TEXT,
        product TEXT,
        action TEXT,       -- clicked / purchased
        reward INTEGER,    -- 0 or 1
        timestamp DATETIME DEFAULT CURRENT_TIMESTAMP
    )
''')
conn.commit()

class CustomerAgent:
    def __init__(self, customer_row):
        self.id = customer_row['Customer_ID']
        self.age = customer_row['Age']
        self.gender = customer_row['Gender']
        self.segment = customer_row['Customer_Segment']
        self.browsing = customer_row['Browsing_History']
        self.purchases = customer_row['Purchase_History']

    def get_preferences(self):
        return self.browsing + self.purchases

customer_agent = CustomerAgent(customer_df.iloc[3])
print("Preferences:", customer_agent.get_preferences())

class ProductAgent:
    def __init__(self, product_row):
        self.id = product_row['Product_ID']
        self.category = product_row['Category']
        self.rating = product_row['Product_Rating']
        self.probability = product_row['Probability_of_Recommendation']
        self.similar = product_row['Similar_Product_List']

product_agent = ProductAgent(product_df.iloc[0])
print("Similar Products:", product_agent.similar)

class RecommendationAgent:
    def __init__(self, customer_agent, product_df):
        self.customer = customer_agent
        self.product_df = product_df

    def recommend(self, top_n=3):
        # Get products that match preferences
        prefs = self.customer.get_preferences()
        filtered = self.product_df[self.product_df['Category'].isin(prefs)]

        if filtered.empty:
            # Fallback to top recommended
            filtered = self.product_df.sort_values(by='Probability_of_Recommendation', ascending=False)

        recommended = filtered.sort_values(by='Probability_of_Recommendation', ascending=False).head(top_n)
        return recommended[['Product_ID', 'Category', 'Product_Rating', 'Probability_of_Recommendation']]

reco_agent = RecommendationAgent(customer_agent, product_df)
reco_agent.recommend()

import sqlite3

conn = sqlite3.connect("recommendation_memory.db")
cursor = conn.cursor()

cursor.execute('''
    CREATE TABLE IF NOT EXISTS agent_logs (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        customer_id TEXT,
        product_id TEXT,
        action TEXT,            -- clicked / purchased
        reward INTEGER,         -- 1 for positive engagement, 0 otherwise
        timestamp DATETIME DEFAULT CURRENT_TIMESTAMP
    )
''')
conn.commit()

def log_interaction(customer_id, product_id, action, reward):
    conn = sqlite3.connect("recommendation_memory.db")
    cursor = conn.cursor()

    cursor.execute('''
        INSERT INTO agent_logs (customer_id, product_id, action, reward)
        VALUES (?, ?, ?, ?)
    ''', (customer_id, product_id, action, reward))

    conn.commit()
    conn.close()

log_interaction('C1003', 'P2004', 'click', 1)
log_interaction('C1003', 'P2001', 'purchase', 1)
log_interaction('C1003', 'P2002', 'ignore', 0)

import random
from collections import defaultdict

class MultiArmedBandit:
    def __init__(self):
        self.q_values = defaultdict(float)
        self.action_counts = defaultdict(int)
        self.epsilon = 0.1  # 10% explore

    def choose_action(self, product_ids):
        if random.random() < self.epsilon:
            return random.choice(product_ids)
        else:
            # Choose product with highest Q-value (reward)
            return max(product_ids, key=lambda pid: self.q_values[pid])

    def update_reward(self, product_id, reward):
        self.action_counts[product_id] += 1
        alpha = 1 / self.action_counts[product_id]  # learning rate
        self.q_values[product_id] += alpha * (reward - self.q_values[product_id])

bandit = MultiArmedBandit()

def bandit_recommend(customer_agent, product_df):
    prefs = customer_agent.get_preferences()
    candidate_products = product_df[product_df['Category'].isin(prefs)]

    if candidate_products.empty:
        candidate_products = product_df

    product_ids = candidate_products['Product_ID'].tolist()
    chosen_product_id = bandit.choose_action(product_ids)

    chosen_product = candidate_products[product_df['Product_ID'] == chosen_product_id].iloc[0]
    return chosen_product

product = bandit_recommend(customer_agent, product_df)
print("Recommended:", product['Product_ID'])

# Simulate user clicked (reward = 1)
bandit.update_reward(product['Product_ID'], 1)
log_interaction(customer_agent.id, product['Product_ID'], 'click', 1)

# Pick a customer
test_customer_row = customer_df[customer_df['Customer_ID'] == 'C1001'].iloc[0]
customer_agent = CustomerAgent(test_customer_row)

# Run bandit-based recommendation
product = bandit_recommend(customer_agent, product_df)
print("ðŸŽ¯ Recommended Product:", product['Product_ID'], "-", product['Category'])

import random

# Simulate click probability
reward = random.choice([1, 0])  # 50% chance of click
action = 'click' if reward == 1 else 'ignore'

print(f"ðŸ‘¤ User {action}ed the product. Reward = {reward}")

# Update bandit model
bandit.update_reward(product['Product_ID'], reward)

# Log to SQLite
log_interaction(customer_agent.id, product['Product_ID'], action, reward)

for _, row in customer_df.iterrows():
    cust_agent = CustomerAgent(row)
    product = bandit_recommend(cust_agent, product_df)
    reward = random.choice([1, 0])
    action = 'click' if reward else 'ignore'

    print(f"\nCustomer: {cust_agent.id} | Recommended: {product['Product_ID']} | Action: {action} | Reward: {reward}")

    bandit.update_reward(product['Product_ID'], reward)
    log_interaction(cust_agent.id, product['Product_ID'], action, reward)

import pandas as pd
import sqlite3

# Connect and read logs
conn = sqlite3.connect("recommendation_memory.db")
logs_df = pd.read_sql_query("SELECT * FROM agent_logs", conn)
conn.close()

# Show the log
logs_df.head()

top_products = logs_df.groupby("product_id")["reward"].sum().sort_values(ascending=False).reset_index()
top_products.columns = ['Product_ID', 'Total_Rewards']
top_products.head()

customer_summary = logs_df.groupby("customer_id")["reward"].agg(['count', 'sum']).reset_index()
customer_summary.columns = ['Customer_ID', 'Total_Interactions', 'Total_Rewards']
customer_summary.head()

import matplotlib.pyplot as plt
import seaborn as sns

plt.figure(figsize=(10,5))
sns.barplot(data=top_products.head(5), x="Product_ID", y="Total_Rewards", palette="Blues_d")
plt.title("ðŸ† Top Recommended Products by Total Reward")
plt.ylabel("Total Clicks/Purchases")
plt.xlabel("Product ID")
plt.show()

plt.figure(figsize=(10,5))
sns.barplot(data=customer_summary, x="Customer_ID", y="Total_Rewards", palette="viridis")
plt.title("ðŸ‘¤ Customer Interaction Reward Summary")
plt.ylabel("Total Reward")
plt.xticks(rotation=45)
plt.show()

logs_df['timestamp'] = pd.to_datetime(logs_df['timestamp'])

plt.figure(figsize=(10,5))
logs_df.groupby('timestamp')['reward'].sum().plot()
plt.title("ðŸ“ˆ Reward Trend Over Time")
plt.ylabel("Total Rewards")
plt.xlabel("Time")
plt.grid(True)
plt.show()

# Load customer and product data
import pandas as pd

customer_df = pd.read_csv("/content/customer_data_collection.csv")
product_df = pd.read_csv("/content/product_recommendation_data.csv")

customer_df.head(2)
product_df.head(2)

import ast

class CustomerAgent:
    def __init__(self, customer_row):
        self.id = customer_row['Customer_ID']
        self.age = customer_row['Age']
        self.gender = customer_row['Gender']
        self.location = customer_row['Location']

        # Convert stringified list to actual list
        self.preferences = ast.literal_eval(customer_row['Browsing_History'])
        self.purchases = ast.literal_eval(customer_row['Purchase_History'])

        self.segment = customer_row['Customer_Segment']
        self.avg_order_value = customer_row['Avg_Order_Value']
        self.holiday = customer_row['Holiday']
        self.season = customer_row['Season']

    def get_preferences(self):
        return self.preferences

    def get_segment(self):
        return self.segment

# Select customer with ID 'C1001' from the customer dataset
customer_row = customer_df[customer_df['Customer_ID'] == 'C1001'].iloc[0]

customer_agent = CustomerAgent(customer_row)

recommended = bandit_recommend(customer_agent, product_df)
print(f"ðŸŽ¯ Recommended Product for {customer_agent.id}: {recommended['Product_ID']} - {recommended['Category']}")

import random
import time

# Select a few sample customers
sample_customers = customer_df.sample(5)

for idx, row in sample_customers.iterrows():
    # Create customer agent
    customer_agent = CustomerAgent(row)

    # Recommend product
    recommended = bandit_recommend(customer_agent, product_df)
    print(f"\nðŸ§‘â€ðŸ’¼ Customer: {customer_agent.id}")
    print(f"ðŸŽ¯ Recommended: {recommended['Product_ID']} - {recommended['Category']}")

    # Simulate interaction
    reward = random.choice([0, 1])  # 1 = clicked/bought, 0 = ignored
    action = "click" if reward else "ignore"
    print(f"ðŸ›’ User {action}ed. Reward = {reward}")

    # Log to SQLite and update reward
    log_interaction(customer_agent.id, recommended['Product_ID'], action, reward)
    bandit.update_reward(recommended['Product_ID'], reward)

    # Pause between each interaction
    time.sleep(1)

import sqlite3

# Connect to SQLite
conn = sqlite3.connect("recommendation_logs.db")
cursor = conn.cursor()

# Check available tables
cursor.execute("SELECT name FROM sqlite_master WHERE type='table';")
tables = cursor.fetchall()
print("ðŸ“Œ Available tables:", tables)

conn.close()

# Reconnect to SQLite
conn = sqlite3.connect("recommendation_logs.db")
cursor = conn.cursor()

# Create interactions table
cursor.execute('''
    CREATE TABLE IF NOT EXISTS interactions (
        customer_id TEXT,
        product_id TEXT,
        action TEXT,
        reward INTEGER,
        timestamp DATETIME DEFAULT CURRENT_TIMESTAMP
    )
''')

conn.commit()
conn.close()
print("âœ… Table 'interactions' created successfully!")

conn = sqlite3.connect("recommendation_logs.db")
cursor = conn.cursor()

# Insert test data
cursor.execute("INSERT INTO interactions (customer_id, product_id, action, reward) VALUES (?, ?, ?, ?)",
               ("C1001", "P2000", "click", 1))

conn.commit()
conn.close()
print("âœ… Test interaction logged!")

conn = sqlite3.connect("recommendation_logs.db")
interaction_df = pd.read_sql("SELECT * FROM interactions", conn)
conn.close()

# Show data
print(interaction_df)

import random
import time

# Select 10 random customers for the simulation
sample_customers = customer_df.sample(10)

for idx, row in sample_customers.iterrows():
    # Create customer agent
    customer_agent = CustomerAgent(row)

    # Recommend product
    recommended = bandit_recommend(customer_agent, product_df)
    print(f"\nðŸ§‘â€ðŸ’¼ Customer: {customer_agent.id}")
    print(f"ðŸŽ¯ Recommended: {recommended['Product_ID']} - {recommended['Category']}")

    # Simulate user feedback (click or ignore)
    reward = random.choice([0, 1])  # 1 = clicked/bought, 0 = ignored
    action = "click" if reward else "ignore"
    print(f"ðŸ›’ User {action}ed. Reward = {reward}")

    # Log the interaction
    conn = sqlite3.connect("recommendation_logs.db")
    cursor = conn.cursor()
    cursor.execute("INSERT INTO interactions (customer_id, product_id, action, reward) VALUES (?, ?, ?, ?)",
                   (customer_agent.id, recommended['Product_ID'], action, reward))
    conn.commit()
    conn.close()

    # Update bandit model
    bandit.update_reward(recommended['Product_ID'], reward)

    # Pause between interactions (optional)
    time.sleep(1)

print("âœ… Simulation completed. Interactions logged successfully!")

conn = sqlite3.connect("recommendation_logs.db")
interaction_df = pd.read_sql("SELECT * FROM interactions", conn)
conn.close()

# Show sample
print(interaction_df.head())

import matplotlib.pyplot as plt

# Compute click-through rate per product
click_rate = interaction_df.groupby('product_id')['reward'].mean().sort_values(ascending=False)

# Plot the results
plt.figure(figsize=(12, 5))
click_rate.plot(kind='bar', color='skyblue')
plt.xlabel("Product ID")
plt.ylabel("Click Rate (CTR)")
plt.title("ðŸ“Š Click Rate per Product")
plt.show()

interaction_df['timestamp'] = pd.to_datetime(interaction_df['timestamp'])
interaction_df.set_index('timestamp', inplace=True)

plt.figure(figsize=(12, 5))
interaction_df.resample('1min')['reward'].mean().plot(marker='o', linestyle='-')
plt.xlabel("Time")
plt.ylabel("Avg Reward (Engagement)")
plt.title("ðŸ“ˆ User Engagement Over Time")
plt.show()

import sqlite3
import pandas as pd

# Connect and read from the SQLite DB
conn = sqlite3.connect("recommendation_logs.db")
interaction_df = pd.read_sql("SELECT * FROM interactions", conn)
conn.close()

# Show the first few rows
interaction_df.head()

import matplotlib.pyplot as plt

# Calculate click-through rate: average reward per product
click_rate = interaction_df.groupby('product_id')['reward'].mean().sort_values(ascending=False)

# Plotting CTR
plt.figure(figsize=(12, 5))
click_rate.plot(kind='bar', color='skyblue')
plt.xlabel("Product ID")
plt.ylabel("Click Rate (CTR)")
plt.title("ðŸ“Š Click-Through Rate (CTR) per Product")
plt.xticks(rotation=45)
plt.grid(axis='y', linestyle='--', alpha=0.7)
plt.tight_layout()
plt.show()

# Make sure 'timestamp' is datetime
interaction_df['timestamp'] = pd.to_datetime(interaction_df['timestamp'])

# Set timestamp as index for resampling
interaction_df.set_index('timestamp', inplace=True)

# Resample by minute and compute average reward (click = 1, ignore = 0)
engagement_trend = interaction_df.resample('1min')['reward'].mean()

# Plot engagement trend
plt.figure(figsize=(12, 5))
engagement_trend.plot(marker='o', linestyle='-', color='green')
plt.xlabel("Time")
plt.ylabel("Average Reward (Engagement)")
plt.title("ðŸ“ˆ User Engagement Over Time")
plt.grid(True, linestyle='--', alpha=0.6)
plt.tight_layout()
plt.show()

# Reset index to include timestamp as a column
interaction_df.reset_index(inplace=True)

# Export to CSV
interaction_df.to_csv("interaction_logs.csv", index=False)
print("âœ… Interaction logs exported as 'interaction_logs.csv'")

!pip install streamlit

streamlit_code = """
import streamlit as st
import pandas as pd
import matplotlib.pyplot as plt
import sqlite3

st.set_page_config(page_title='ðŸ§  AI Recommendation Dashboard', layout='wide')

st.title("ðŸ“Š AI-Powered Product Recommendation Dashboard")
st.markdown("This dashboard shows interaction logs, click-through rates, and engagement over time.")

# Connect to SQLite DB
conn = sqlite3.connect("recommendation_logs.db")
interaction_df = pd.read_sql("SELECT * FROM interactions", conn)
conn.close()

# Click-Through Rate (CTR) Chart
st.subheader("ðŸ” Click-Through Rate (CTR) per Product")
ctr = interaction_df.groupby('product_id')['reward'].mean().sort_values(ascending=False)
fig1, ax1 = plt.subplots(figsize=(10, 4))
ctr.plot(kind='bar', ax=ax1, color='skyblue')
ax1.set_xlabel("Product ID")
ax1.set_ylabel("CTR")
ax1.set_title("Click-Through Rate")
st.pyplot(fig1)

# Engagement Trend Over Time
st.subheader("â±ï¸ Engagement Over Time")
interaction_df['timestamp'] = pd.to_datetime(interaction_df['timestamp'])
interaction_df.set_index('timestamp', inplace=True)
engagement_trend = interaction_df.resample('1min')['reward'].mean()
fig2, ax2 = plt.subplots(figsize=(10, 4))
engagement_trend.plot(marker='o', linestyle='-', ax=ax2, color='green')
ax2.set_xlabel("Time")
ax2.set_ylabel("Avg Reward")
ax2.set_title("Engagement Trend")
st.pyplot(fig2)

# Data Download
st.subheader("ðŸ“¥ Download Logs")
st.download_button("Download as CSV", interaction_df.reset_index().to_csv(index=False), file_name="interaction_logs.csv", mime='text/csv')

st.success("Dashboard Ready! ðŸŽ‰")
"""

# Save to a .py file
with open("streamlit_dashboard.py", "w") as f:
    f.write(streamlit_code)

print("âœ… Streamlit app saved as 'streamlit_dashboard.py'")

pip install streamlit

from google.colab import files
files.download("streamlit_dashboard.py")

files.download("recommendation_logs.db")